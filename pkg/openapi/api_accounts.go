/*
 * Chariot Payments API
 *
 * The Chariot Payments REST API.
 *
 * API version: v1
 * Contact: developers@givechariot.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"net/http"

	"github.com/chariot-giving/agapay/pkg/bank"
	"github.com/gin-gonic/gin"
	"github.com/increase/increase-go"
)

// CreateAccount - Create an account
func CreateAccount(c *gin.Context) {
	account := new(Account)
	err := c.Bind(account)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// idempotencyKey := c.GetHeader("Idempotency-Key")
	// if idempotencyKey == "" {
	// 	c.JSON(http.StatusBadRequest, gin.H{"error": "Idempotency-Key header is required"})
	// 	return
	// }

	// TODO: add our own database + idempotency key logic to prevent duplicate accounts

	bankAccount, err := bank.IncreaseClient.Accounts.New(c, increase.AccountNewParams{
		Name: increase.String(account.Name),
		//EntityID:              increase.String("account.EntityID"),              // TODO: figure out what this should be for an FBO account
		//InformationalEntityID: increase.String("account.InformationalEntityID"), // TODO: figure out what this should be for an FBO account - most likely need to create an entity that represents each payer
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// create new idempotency key based on original key + account number
	//accountNoIdempotencyKey := sha256.Sum256([]byte(idempotencyKey + "account_number"))

	accountNo, err := bank.IncreaseClient.AccountNumbers.New(c, increase.AccountNumberNewParams{
		AccountID: increase.String(bankAccount.ID),
		Name:      increase.String(account.Name),
		InboundACH: increase.F[increase.AccountNumberNewParamsInboundACH](increase.AccountNumberNewParamsInboundACH{
			DebitStatus: increase.F[increase.AccountNumberNewParamsInboundACHDebitStatus](increase.AccountNumberNewParamsInboundACHDebitStatusBlocked),
		}),
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// update account
	account.Id = bankAccount.ID
	account.AccountNumber = accountNo.AccountNumber
	account.RoutingNumber = accountNo.RoutingNumber
	account.Status = string(bankAccount.Status)
	account.CreatedAt = bankAccount.CreatedAt

	c.Header("Location", "/accounts/"+account.Id)
	c.JSON(http.StatusCreated, account)
}

// GetAccount - Retrieve an account
func GetAccount(c *gin.Context) {
	id := c.Param("id")

	bankAccount, err := bank.IncreaseClient.Accounts.Get(c, id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	accountNumbers, err := bank.IncreaseClient.AccountNumbers.List(c, increase.AccountNumberListParams{
		AccountID: increase.String(bankAccount.ID),
		Status:    increase.F[increase.AccountNumberListParamsStatus](increase.AccountNumberListParamsStatusActive),
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	if len(accountNumbers.Data) == 0 {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "no account numbers found"})
		return
	}

	accountNo := accountNumbers.Data[0]

	account := Account{
		Id:            bankAccount.ID,
		Name:          bankAccount.Name,
		Status:        string(bankAccount.Status),
		CreatedAt:     bankAccount.CreatedAt,
		AccountNumber: accountNo.AccountNumber,
		RoutingNumber: accountNo.RoutingNumber,
	}

	c.JSON(http.StatusOK, &account)
}
