/*
 * Chariot Payments API
 *
 * The Chariot Payments REST API.
 *
 * API version: v1
 * Contact: developers@givechariot.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"errors"
	"net/http"
	"strconv"

	"github.com/chariot-giving/agapay/pkg/atomic"
	"github.com/chariot-giving/agapay/pkg/auth"
	"github.com/chariot-giving/agapay/pkg/cerr"
	"github.com/chariot-giving/agapay/pkg/core"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

// GetTransfer - Retrieve a transfer
func (api *openAPIServer) GetTransfer(c *gin.Context) {
	id := c.Param("id")

	transfer, err := api.core.Transfers.Get(c, id)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to retrieve transfer", err))
		return
	}

	c.JSON(http.StatusOK, &Transfer{
		Id:            strconv.FormatUint(transfer.Transfer.Id, 10),
		AccountId:     strconv.FormatUint(transfer.Transfer.AccountId, 10),
		Description:   transfer.Transfer.Description,
		Amount:        int64(transfer.Transfer.Amount),
		AccountNumber: transfer.BankTransfer.AccountNumber,
		RoutingNumber: transfer.BankTransfer.RoutingNumber,
		Funding:       string(transfer.BankTransfer.Funding),
		TransactionId: transfer.BankTransfer.TransactionID,
		Status:        transfer.BankTransfer.Status,
		CreatedAt:     *transfer.Transfer.CreatedAt,
	})
}

// ListTransfers - List transfers
func (api *openAPIServer) ListTransfers(c *gin.Context) {
	limitQuery := c.DefaultQuery("limit", "100")
	limit, err := strconv.Atoi(limitQuery)
	if err != nil {
		limit = 100
	}

	accountId := c.GetUint64("account_id")
	if accountId == 0 {
		c.Error(cerr.NewBadRequest("account_id is required", nil))
		c.Abort()
		return
	}

	listParams := core.ListTransfersRequest{
		UserID:    auth.UserId(c),
		AccountID: accountId,
		Limit:     limit,
	}

	cursor, ok := c.GetQuery("cursor")
	if ok {
		listParams.Cursor = cursor
	}

	response, err := api.core.Transfers.List(c, listParams)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to list transfers", err))
		return
	}

	transfers := make([]Transfer, len(response.Transfers))
	for i, transfer := range response.Transfers {
		transfers[i] = Transfer{
			Id:          strconv.FormatUint(transfer.Id, 10),
			AccountId:   strconv.FormatUint(transfer.AccountId, 10),
			Description: transfer.Description,
			Amount:      int64(transfer.Amount),
			CreatedAt:   *transfer.CreatedAt,
		}
	}

	transferList := TransferList{
		Data: transfers,
		Paging: Pagination{
			Total: int32(len(response.Transfers)),
			Cursors: PaginationCursors{
				Before: cursor,
				After:  response.NextCursor,
			},
		},
	}

	c.JSON(http.StatusOK, &transferList)
}

// TransferFunds - Transfer funds
func (api *openAPIServer) TransferFunds(c *gin.Context) {
	logger := c.Value("logger").(*zap.Logger)

	transfer := new(Transfer)
	err := c.Bind(transfer)
	if err != nil {
		c.Error(cerr.NewBadRequest("invalid request body", err))
		return
	}

	idempotencyKey := c.GetHeader("Idempotency-Key")
	if idempotencyKey == "" {
		idempotencyKey = uuid.NewString()
	}
	c.Header("Idempotency-Key", idempotencyKey)

	logger.Info("creating transfer", zap.String("idempotency_key", idempotencyKey))

	params := make(map[string]string)
	for _, v := range c.Params {
		params[v.Key] = v.Value
	}
	request := &atomic.IdempotentRequest{
		UserId:         auth.UserId(c),
		IdempotencyKey: idempotencyKey,
		Method:         c.Request.Method,
		Path:           c.Request.URL.Path,
		Params:         params,
		Body:           transfer,
	}

	accountId, err := strconv.ParseUint(transfer.AccountId, 10, 64)
	if err != nil {
		c.Error(cerr.NewBadRequest("invalid account_id", err))
		return
	}
	createTransfer := core.CreateTransferRequest{
		AccountID:     accountId,
		Description:   transfer.Description,
		Amount:        transfer.Amount,
		AccountNumber: transfer.AccountNumber,
		RoutingNumber: transfer.RoutingNumber,
		Funding:       transfer.Funding,
	}

	key, err := api.core.Transfers.Create(c, request, &createTransfer)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to create transfer", err))
		return
	}

	c.JSON(key.ResponseCode, key.ResponseBody)
}
