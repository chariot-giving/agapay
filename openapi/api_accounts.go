/*
 * Chariot Payments API
 *
 * The Chariot Payments REST API.
 *
 * API version: v1
 * Contact: developers@givechariot.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"net/http"
	"strconv"

	"github.com/chariot-giving/agapay/pkg/bank"
	"github.com/chariot-giving/agapay/pkg/cerr"
	"github.com/gin-gonic/gin"
	"github.com/increase/increase-go"
)

// CreateAccount - Create an account
func CreateAccount(c *gin.Context) {
	account := new(Account)
	err := c.Bind(account)
	if err != nil {
		c.Error(cerr.NewBadRequest("invalid request body", err))
		return
	}

	// idempotencyKey := c.GetHeader("Idempotency-Key")
	// if idempotencyKey == "" {
	// 	c.JSON(http.StatusBadRequest, gin.H{"error": "Idempotency-Key header is required"})
	// 	return
	// }

	// TODO: add our own database + idempotency key logic to prevent duplicate accounts

	newParams := increase.AccountNewParams{
		Name: increase.String(account.Name),
	}

	entity, ok := c.Get("entity")
	if ok {
		newParams.EntityID = increase.String(entity.(string)) // TODO: figure out what this should be for an FBO account
	}

	bankAccount, err := bank.IncreaseClient.Accounts.New(c, newParams)
	if err != nil {
		c.JSON(http.StatusBadGateway, cerr.NewBadGatewayError("error creating account", err))
		return
	}

	// create new idempotency key based on original key + account number
	//accountNoIdempotencyKey := sha256.Sum256([]byte(idempotencyKey + "account_number"))

	accountNo, err := bank.IncreaseClient.AccountNumbers.New(c, increase.AccountNumberNewParams{
		AccountID: increase.String(bankAccount.ID),
		Name:      increase.String(account.Name),
		InboundACH: increase.F[increase.AccountNumberNewParamsInboundACH](increase.AccountNumberNewParamsInboundACH{
			DebitStatus: increase.F[increase.AccountNumberNewParamsInboundACHDebitStatus](increase.AccountNumberNewParamsInboundACHDebitStatusBlocked),
		}),
	})
	if err != nil {
		c.JSON(http.StatusBadGateway, cerr.NewBadGatewayError("error creating account number", err))
		return
	}

	// update account
	account.Id = bankAccount.ID
	account.AccountNumber = accountNo.AccountNumber
	account.RoutingNumber = accountNo.RoutingNumber
	account.Status = string(bankAccount.Status)
	account.CreatedAt = bankAccount.CreatedAt

	c.Header("Location", "/accounts/"+account.Id)
	c.JSON(http.StatusCreated, account)
}

// GetAccount - Retrieve an account
func GetAccount(c *gin.Context) {
	id := c.Param("id")

	bankAccount, err := bank.IncreaseClient.Accounts.Get(c, id)
	if err != nil {
		c.JSON(http.StatusBadGateway, cerr.NewBadGatewayError("error retrieving account", err))
		return
	}

	accountNumbers, err := bank.IncreaseClient.AccountNumbers.List(c, increase.AccountNumberListParams{
		AccountID: increase.String(bankAccount.ID),
		Status:    increase.F[increase.AccountNumberListParamsStatus](increase.AccountNumberListParamsStatusActive),
	})
	if err != nil {
		c.JSON(http.StatusBadGateway, cerr.NewBadGatewayError("error retrieving account numbers", err))
		return
	}

	if len(accountNumbers.Data) == 0 {
		c.JSON(http.StatusNotFound, cerr.NewNotFoundError("account number not found", nil))
		return
	}

	accountNo := accountNumbers.Data[0]

	account := Account{
		Id:            bankAccount.ID,
		Name:          bankAccount.Name,
		Status:        string(bankAccount.Status),
		CreatedAt:     bankAccount.CreatedAt,
		AccountNumber: accountNo.AccountNumber,
		RoutingNumber: accountNo.RoutingNumber,
	}

	c.JSON(http.StatusOK, &account)
}

// ListAccounts - List accounts
func ListAccounts(c *gin.Context) {
	limitQuery := c.DefaultQuery("limit", "100")
	limit, err := strconv.ParseInt(limitQuery, 10, 64)
	if err != nil {
		limit = 100
	}

	listParams := increase.AccountListParams{
		Limit: increase.Int(limit),
	}

	cursor, ok := c.GetQuery("cursor")
	if ok {
		listParams.Cursor = increase.String(cursor)
	} else {
		listParams.Cursor = increase.Null[string]()
	}

	// this comes from auth middleware
	entity := c.Value("entity")
	if entity != nil {
		listParams.EntityID = increase.String(entity.(string))
	}

	response, err := bank.IncreaseClient.Accounts.List(c, listParams)
	if err != nil {
		c.JSON(http.StatusBadGateway, cerr.NewBadGatewayError("error listing accounts", err))
		return
	}

	accounts := make([]Account, len(response.Data))
	for i, bankAccount := range response.Data {
		accounts[i] = Account{
			Id:        bankAccount.ID,
			Name:      bankAccount.Name,
			Status:    string(bankAccount.Status),
			CreatedAt: bankAccount.CreatedAt,
		}
	}

	accountList := AccountList{
		Data: accounts,
		Paging: Pagination{
			Total: int32(len(response.Data)),
			Cursors: PaginationCursors{
				Before: cursor,
				After:  response.NextCursor,
			},
		},
	}

	c.JSON(http.StatusOK, &accountList)
}
