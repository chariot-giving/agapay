/*
 * Chariot Payments API
 *
 * The Chariot Payments REST API.
 *
 * API version: v1
 * Contact: developers@givechariot.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"errors"
	"net/http"
	"strconv"

	"github.com/chariot-giving/agapay/pkg/atomic"
	"github.com/chariot-giving/agapay/pkg/auth"
	"github.com/chariot-giving/agapay/pkg/bank"
	"github.com/chariot-giving/agapay/pkg/cerr"
	"github.com/chariot-giving/agapay/pkg/core"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/increase/increase-go"
	"go.uber.org/zap"
)

// CreateAccount - Create an account
func (api *OpenAPIServer) CreateAccount(c *gin.Context) {
	logger := c.Value("logger").(*zap.Logger)

	requestBody := new(Account)
	err := c.Bind(requestBody)
	if err != nil {
		c.Error(cerr.NewBadRequest("invalid request body", err))
		return
	}

	idempotencyKey := c.GetHeader("Idempotency-Key")
	if idempotencyKey == "" {
		idempotencyKey = uuid.NewString()
	}
	c.Header("Idempotency-Key", idempotencyKey)

	logger.Info("creating account", zap.String("idempotency_key", idempotencyKey))

	params := make(map[string]string)
	for _, v := range c.Params {
		params[v.Key] = v.Value
	}
	request := &atomic.IdempotentRequest{
		UserId:         auth.UserId(c),
		IdempotencyKey: idempotencyKey,
		Method:         c.Request.Method,
		Path:           c.Request.URL.Path,
		Params:         params,
		Body:           requestBody,
	}
	key, err := api.core.UpsertIdempotencyKey(c, request)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to upsert idempotency key", err))
		return
	}

	logger.Info("idempotency key upserted", zap.String("idempotency_key", idempotencyKey))

	account := new(core.Account)

	// start the state machine
	for {
		switch key.RecoveryPoint {
		case atomic.RecoveryPointStarted:
			// create the account
			account = &core.Account{
				IdempotencyKeyId: key.Id,
				UserId:           strconv.FormatUint(key.UserId, 10),
				Name:             requestBody.Name,
			}
			_, err := api.core.CreateAccount(c, key, account)
			if err != nil {
				cErr := new(cerr.HttpError)
				if errors.As(err, &cErr) {
					c.Error(cErr)
					return
				}
				c.Error(cerr.NewInternalServerError("failed to create account", err))
				return
			}
		case atomic.RecoveryPointAccountCreated:
			// create the bank account
			_, err := api.core.CreateBankAccount(c, key, account)
			if err != nil {
				cErr := new(cerr.HttpError)
				if errors.As(err, &cErr) {
					c.Error(cErr)
					return
				}
				c.Error(cerr.NewInternalServerError("failed to create bank account", err))
				return
			}
		case atomic.RecoveryPointBankAccountCreated:
			// create the bank account number
			_, err := api.core.CreateBankAccountNumber(c, key, account)
			if err != nil {
				cErr := new(cerr.HttpError)
				if errors.As(err, &cErr) {
					c.Error(cErr)
					return
				}
				c.Error(cerr.NewInternalServerError("failed to create bank account number", err))
				return
			}
		case atomic.RecoveryPointFinished:
			// we're done
		default:
			c.Error(cerr.NewInternalServerError("bug: unknown recovery point", nil))
			return
		}

		// if we're done, break out of the loop
		if key.RecoveryPoint == atomic.RecoveryPointFinished {
			break
		}
	}

	c.JSON(key.ResponseCode, key.ResponseBody)
}

// GetAccount - Retrieve an account
func (api *OpenAPIServer) GetAccount(c *gin.Context) {
	id := c.Param("id")

	account, err := api.core.GetAccount(c, id)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to retrieve account", err))
		return
	}

	c.JSON(http.StatusOK, &account)
}

// GetAccountDetails - Retrieve account details
func (api *OpenAPIServer) GetAccountDetails(c *gin.Context) {
	id := c.Param("id")

	bankAccount, err := bank.IncreaseClient.Accounts.Get(c, id)
	if err != nil {
		c.JSON(http.StatusBadGateway, cerr.NewBadGatewayError("error retrieving account", err))
		return
	}

	accountNumbers, err := bank.IncreaseClient.AccountNumbers.List(c, increase.AccountNumberListParams{
		AccountID: increase.String(bankAccount.ID),
		Status:    increase.F[increase.AccountNumberListParamsStatus](increase.AccountNumberListParamsStatusActive),
	})
	if err != nil {
		c.JSON(http.StatusBadGateway, cerr.NewBadGatewayError("error retrieving account numbers", err))
		return
	}

	if len(accountNumbers.Data) == 0 {
		c.JSON(http.StatusNotFound, cerr.NewNotFoundError("account number not found", nil))
		return
	}

	accountNo := accountNumbers.Data[0]

	// TODO: create audit log record for accessing account details

	accountDetails := AccountDetails{
		AccountNumber: accountNo.AccountNumber,
		RoutingNumber: accountNo.RoutingNumber,
		Status:        string(bankAccount.Status),
	}

	c.JSON(http.StatusOK, accountDetails)
}

// ListAccounts - List accounts
func ListAccounts(c *gin.Context) {
	limitQuery := c.DefaultQuery("limit", "100")
	limit, err := strconv.ParseInt(limitQuery, 10, 64)
	if err != nil {
		limit = 100
	}

	listParams := increase.AccountListParams{
		Limit: increase.Int(limit),
	}

	cursor, ok := c.GetQuery("cursor")
	if ok {
		listParams.Cursor = increase.String(cursor)
	} else {
		listParams.Cursor = increase.Null[string]()
	}

	// this comes from auth middleware
	entity := c.Value("entity")
	if entity != nil {
		listParams.EntityID = increase.String(entity.(string))
	}

	response, err := bank.IncreaseClient.Accounts.List(c, listParams)
	if err != nil {
		c.JSON(http.StatusBadGateway, cerr.NewBadGatewayError("error listing accounts", err))
		return
	}

	accounts := make([]Account, len(response.Data))
	for i, bankAccount := range response.Data {
		accounts[i] = Account{
			Id:        bankAccount.ID,
			Name:      bankAccount.Name,
			CreatedAt: bankAccount.CreatedAt,
		}
	}

	accountList := AccountList{
		Data: accounts,
		Paging: Pagination{
			Total: int32(len(response.Data)),
			Cursors: PaginationCursors{
				Before: cursor,
				After:  response.NextCursor,
			},
		},
	}

	c.JSON(http.StatusOK, &accountList)
}
