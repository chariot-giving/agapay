/*
 * Chariot Payments API
 *
 * The Chariot Payments REST API.
 *
 * API version: v1
 * Contact: developers@givechariot.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"errors"
	"net/http"
	"strconv"

	"github.com/chariot-giving/agapay/pkg/atomic"
	"github.com/chariot-giving/agapay/pkg/auth"
	"github.com/chariot-giving/agapay/pkg/cerr"
	"github.com/chariot-giving/agapay/pkg/core"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

// CreateAccount - Create an account
func (api *openAPIServer) CreateAccount(c *gin.Context) {
	logger := c.Value("logger").(*zap.Logger)

	requestBody := new(Account)
	err := c.Bind(requestBody)
	if err != nil {
		c.Error(cerr.NewBadRequest("invalid request body", err))
		return
	}

	idempotencyKey := c.GetHeader("Idempotency-Key")
	if idempotencyKey == "" {
		idempotencyKey = uuid.NewString()
	}
	c.Header("Idempotency-Key", idempotencyKey)

	logger.Info("creating account", zap.String("idempotency_key", idempotencyKey))

	params := make(map[string]string)
	for _, v := range c.Params {
		params[v.Key] = v.Value
	}
	request := &atomic.IdempotentRequest{
		UserId:         auth.UserId(c),
		IdempotencyKey: idempotencyKey,
		Method:         c.Request.Method,
		Path:           c.Request.URL.Path,
		Params:         params,
		Body:           requestBody,
	}

	createAccount := core.CreateAccountRequest{
		Name: requestBody.Name,
	}

	key, err := api.core.Accounts.Create(c, request, &createAccount)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to create account", err))
		return
	}

	c.JSON(key.ResponseCode, key.ResponseBody)
}

// GetAccount - Retrieve an account
func (api *openAPIServer) GetAccount(c *gin.Context) {
	id := c.Param("id")

	account, err := api.core.Accounts.Get(c, id)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to retrieve account", err))
		return
	}

	c.JSON(http.StatusOK, &account)
}

// GetAccountDetails - Retrieve account details
func (api *openAPIServer) GetAccountDetails(c *gin.Context) {
	id := c.Param("id")

	bankDetails, err := api.core.Accounts.GetDetails(c, id)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to retrieve account details", err))
		return
	}

	achNumbers := make([]AchNumber, len(bankDetails.Numbers))
	for i, number := range bankDetails.Numbers {
		achNumbers[i] = AchNumber{
			AccountNumber: number.AccountNumber,
			RoutingNumber: number.RoutingNumber,
		}
	}

	accountDetails := AccountDetails{
		Numbers: AccountNumbers{
			Ach: achNumbers,
		},
		Status: string(bankDetails.Status),
	}

	c.JSON(http.StatusOK, accountDetails)
}

// ListAccounts - List accounts
func (api *openAPIServer) ListAccounts(c *gin.Context) {
	limitQuery := c.DefaultQuery("limit", "100")
	limit, err := strconv.Atoi(limitQuery)
	if err != nil {
		limit = 100
	}

	listParams := core.ListAccountsRequest{
		Limit:  limit,
		UserID: auth.UserId(c),
	}

	cursor, ok := c.GetQuery("cursor")
	if ok {
		listParams.Cursor = cursor
	}

	response, err := api.core.Accounts.List(c, listParams)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("error listing accounts", err))
		return
	}

	accounts := make([]Account, len(response.Accounts))
	for i, account := range response.Accounts {
		accounts[i] = Account{
			Id:                    strconv.Itoa(int(account.Id)),
			Name:                  account.Name,
			UsBankAccountId:       *account.BankAccountId,
			UsBankAccountNumberId: *account.BankAccountNumberId,
			CreatedAt:             *account.CreatedAt,
		}
	}

	accountList := AccountList{
		Data: accounts,
		Paging: Pagination{
			Total: int32(len(response.Accounts)),
			Cursors: PaginationCursors{
				Before: cursor,
				After:  response.NextCursor,
			},
		},
	}

	c.JSON(http.StatusOK, &accountList)
}
