/*
 * Chariot Payments API
 *
 * The Chariot Payments REST API.
 *
 * API version: v1
 * Contact: developers@givechariot.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"errors"
	"net/http"
	"strconv"

	"github.com/chariot-giving/agapay/pkg/atomic"
	"github.com/chariot-giving/agapay/pkg/auth"
	"github.com/chariot-giving/agapay/pkg/cerr"
	"github.com/chariot-giving/agapay/pkg/core"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

// CreatePayment - Create a payment
func (api *openAPIServer) CreatePayment(c *gin.Context) {
	logger := c.Value("logger").(*zap.Logger)

	payment := new(Payment)
	err := c.Bind(payment)
	if err != nil {
		c.Error(cerr.NewBadRequest("invalid request body", err))
		return
	}

	idempotencyKey := c.GetHeader("Idempotency-Key")
	if idempotencyKey == "" {
		idempotencyKey = uuid.NewString()
	}
	c.Header("Idempotency-Key", idempotencyKey)

	logger.Info("creating payment", zap.String("idempotency_key", idempotencyKey))

	params := make(map[string]string)
	for _, v := range c.Params {
		params[v.Key] = v.Value
	}
	request := &atomic.IdempotentRequest{
		UserId:         auth.UserId(c),
		IdempotencyKey: idempotencyKey,
		Method:         c.Request.Method,
		Path:           c.Request.URL.Path,
		Params:         params,
		Body:           payment,
	}

	accountId, err := strconv.ParseUint(payment.AccountId, 10, 64)
	if err != nil {
		c.Error(cerr.NewBadRequest("invalid account_id", err))
		return
	}
	recipientId, err := strconv.ParseUint(payment.RecipientId, 10, 64)
	if err != nil {
		c.Error(cerr.NewBadRequest("invalid recipient_id", err))
		return
	}
	createPayment := core.CreatePaymentRequest{
		AccountID:   accountId,
		Description: payment.Description,
		Amount:      payment.Amount,
		RecipientID: recipientId,
	}

	key, err := api.core.Payments.Create(c, request, &createPayment)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to create payment", err))
		return
	}

	c.JSON(key.ResponseCode, key.ResponseBody)
}

// GetPayment - Retrieve a payment
func (api *openAPIServer) GetPayment(c *gin.Context) {
	id := c.Param("id")

	payment, err := api.core.Payments.Get(c, id)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to retrieve payment", err))
		return
	}

	c.JSON(http.StatusOK, &Payment{
		Id:            strconv.FormatUint(payment.Payment.Id, 10),
		AccountId:     strconv.FormatUint(payment.Payment.AccountId, 10),
		Description:   payment.Payment.Description,
		Amount:        int64(payment.Payment.Amount),
		RecipientId:   strconv.FormatUint(payment.Payment.RecipientId, 10),
		TransactionId: payment.BankPayment.TransactionID,
		Status:        payment.BankPayment.Status,
	})
}

// ListPayments - List payments
func (api *openAPIServer) ListPayments(c *gin.Context) {
	limitQuery := c.DefaultQuery("limit", "100")
	limit, err := strconv.Atoi(limitQuery)
	if err != nil {
		limit = 100
	}

	accountIdQuery, ok := c.GetQuery("account_id")
	if !ok {
		c.Error(cerr.NewBadRequest("account_id is required", nil))
		return
	}
	accountId, err := strconv.ParseUint(accountIdQuery, 10, 64)
	if err != nil {
		c.Error(cerr.NewBadRequest("account_id parameter is malformed", err))
		return
	}

	var recipientId uint64
	recipientIdQuery, ok := c.GetQuery("recipient_id")
	if ok {
		result, err := strconv.ParseUint(recipientIdQuery, 10, 64)
		if err != nil {
			c.Error(cerr.NewBadRequest("recipient_id parameter is malformed", err))
			return
		}
		recipientId = result
	}

	listParams := core.ListPaymentsRequest{
		UserID:      auth.UserId(c),
		AccountID:   accountId,
		RecipientID: recipientId,
		Limit:       limit,
	}

	cursor, ok := c.GetQuery("cursor")
	if ok {
		listParams.Cursor = cursor
	}

	response, err := api.core.Payments.List(c, listParams)
	if err != nil {
		cErr := new(cerr.HttpError)
		if errors.As(err, &cErr) {
			c.Error(cErr)
			return
		}
		c.Error(cerr.NewInternalServerError("failed to list payments", err))
		return
	}

	payments := make([]Payment, len(response.Payments))
	for i, payment := range response.Payments {
		payments[i] = Payment{
			Id:          strconv.FormatUint(payment.Id, 10),
			AccountId:   strconv.FormatUint(payment.AccountId, 10),
			Description: payment.Description,
			Amount:      int64(payment.Amount),
			CreatedAt:   *payment.CreatedAt,
		}
	}

	paymentList := PaymentList{
		Data: payments,
		Paging: Pagination{
			Total: int32(len(response.Payments)),
			Cursors: PaginationCursors{
				Before: cursor,
				After:  response.NextCursor,
			},
		},
	}

	c.JSON(http.StatusOK, &paymentList)
}
